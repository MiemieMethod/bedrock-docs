---
title: 关于NBT（命名二进制标签）
category: 深入了解NBT
mentions:
    - ConsoleTerm
    - SmokeyStack
    - ThomasOrs
    - theaddonn
    - killcerr
tags:
    - 专家
description: 深入了解NBT。
---

NBT（命名二进制标签）是一种在二进制级别的数据编码格式，您一定知道基于文本级别的JSON格式。因此，我们将能够使用JSON格式进行一些示例，您可能还会注意到Minecraft本身在命令中使用JSON来表示NBT，例如Java命令或简化的基岩命令（`/give`、`/replaceitem`）。请参见[NBT命令](/commands/nbt-commands)。

在本文中，我们将比您预期的更详细地展示NBT。您在命令部分看到的内容与实际的NBT相去甚远，我们将向您展示NBT是如何工作的，如何读取它们，以及`Minecraft基岩版`本身是如何使用它们的。

## NBT标签和数据类型
NBT与JSON一样，具有给定类型并知道如何读取它们，例如JSON知道复合对象以符号`{`开头并以`}`结尾，它还知道在读取字符串时，字符串总是以符号`"`开头并以`"`结尾。这意味着我们想要学习如何读取和理解NBT，因此您需要知道复合对象何时开始，以及如何读取各个类型。现在让我们看看NBT标签的表格，以了解NBT类型及其在NBT中的标记方式。正如所说，NBT在二进制级别工作，因此您需要知道最小的数据类型是字节，大小为8位。各个类型可以包含多个字节，但它们绝不能多出或少于1/2字节，这是不可能的！我们也无法说标签应该如何命名，因为每个人都可以以不同的方式命名NBT标签，但它们必须始终具有相同的二进制基础（`id`），id由一个字节表示。

|      名称       | 二进制ID |   二进制大小    | 描述                                                                                                                                                     |
|:---------------:|----------:|:-----------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
|      字节       |      0x01 |  1字节（8位）    | 一个字节整数                                                                                                                                                |
|  Int16（短整型） |      0x02 | 2字节（16位）    | 一个两字节整数                                                                                                                                              |
| Int32（整型）   |      0x03 | 4字节（32位）    | 一个四字节整数                                                                                                                                             |
|  Int64（长整型） |      0x04 | 8字节（64位）    | 一个八字节整数                                                                                                                                           |
|      浮点      |      0x05 | 4字节（32位）    | 一个四字节（单精度）浮点数，具有常规小数精度，遵循IEEE 754标准                                                                                          |
|     双精度      |      0x06 | 8字节（64位）    | 一个八字节（双精度）浮点数，具有更高的小数精度，遵循IEEE 754标准                                                                                       |
|     字符串      |      0x08 |    预定义        | 一种具有预定义大小的字符串类型。文本使用UTF-8编码                                                                                                      |
|      列表       |      0x09 |    预定义        | 一种具有预定义大小和元素类型定义的列表类型                                                                                                            |
|    复合体      | 0x0A（10） |     未定义       | 复合类型，复合体没有预定义大小，因此必须读取键和值，直到遇到结束复合的标签。                                                                            |
|  复合结束标记  |      0x00 |      1字节       | 此标签不是类型，而只是一个标签，仅在复合体中使用。它标记复合体的结束                                                                                  |
|    字节列表     |      0x07 |    预定义        | 字节类型的列表，具有预定义大小，Minecraft基岩版中不常用                                                                                                   |
|    整型列表     | 0x0B（11） |    预定义        | 整型类型的列表，具有预定义大小，Minecraft基岩版中不常用                                                                                                   |
|    长整型列表   | 0x0C（12） |    预定义        | 长整型类型的列表，具有预定义大小，Minecraft基岩版中不常用                                                                                                   |

您可能会注意到没有像JSON中的布尔值，这意味着我们将用1和0来表示真/假值，使用字节。

## 如何读取/写入NBT标签
相同的读取方法适用于所有数字，读取的字节数与数字标签类型的大小相同，例如：Int16（短整型）大小为2字节，因此我将读取2字节，但您需要知道Minecraft基岩版使用[小端](#little-endian)，与Java不同，它使用大端。 [小端](#little-endian)是一种写入或读取数字字节的方法。

### 读取类型
类型始终为1字节大小，因此我们读取类型并找出接下来要读取的标签。

### 读取数字
读取数字时，需要知道我们正在读取的数字类型，我们可以通过读取类型来确定 *([读取类型](#reading-types))*。然后，当我们知道要读取的数字类型时，我们就读取它，例如，如果我们知道我们想要类型`3`，那么我们在表中查找，知道类型3是一个4字节大小的数字，因此我们读取4字节。所有数字***基岩版***都使用[小端](#little-endian)方法进行读取/写入。

### 读取字符串
读取字符串时，您需要知道其字节长度，此字符串长度始终用Int16（短整型）`2字节`表示（[如何读取数字](#reading-numbers)），在字符串之前，即首先读取数字，然后读取之前读取的数字的字节数，知道字节后，我们可以通过UTF-8编码将其填充，从中获取文本。

### 读取列表
读取列表时，我们必须首先读取列表的类型（[类型](#reading-types)），无论该列表包含数字、其他列表、字符串等。因此，我们首先读取该列表的类型，然后读取作为Int32（整型）数字表示的元素数量，因此我们读取4字节，现在我们知道元素的类型及其数量，因此我们根据之前读取的数字读取该类型的元素。读取列表的大小与读取字符串的大小不同！应读取Int32而不是Int16！此解决方案不适用于`字节列表、整型列表、长整型列表`！

### 读取复合体
复合体具有所有命名属性，因此在读取属性时，始终需要读取其名称。读取复合体的过程相对简单。首先，我们读取类型，类型可以是任何类型，但如果等于一个空字节，则表示复合体的结束，然后我们就停止读取；但如果类型不等于复合体结束标签，则表示我们将要读取的属性的显著类型。读取的属性后面总是跟着名称（键），需要作为[字符串](#reading-strings)读取，读取字符串后，我们就可以读取值。

## Minecraft基岩版NBT文件
读取Minecraft NBT文件时，始终需要小心文件开头是否没有基岩头部，请参见[基岩NBT头部](#bedrock-nbt-file-header)，但并非所有基岩NBT文件都包含此头部，例如`.mcstructure`也不包含基岩NBT头部，与`level.dat`不同。您还需要注意文件中的根元素，即列表或复合体，根元素看起来也像一个属性，因此您需要读取此根属性的名称，尽管基岩版不使用这些名称，因此这些名称是空的，但它们确实存在。以下是`.mcstructure`的样子，其中JSON表示NBT。
```json
"": {
    "format_version":1,
    "size":[], //...
    "structure":{}, //...
    "structure_world_origin":[] //..
}
```
:::warning
此示例显示，读取基本元素的名称也是必要的，尽管通常未使用且为空。
:::

## 写入NBT
写入没有特定的程序，因为与读取时的方法相同，但反向进行。因此，我们建议首先理解NBT并学习正确读取它，然后写入NBT就不会困难。

## 基岩NBT文件头
基岩NBT头部由两个4字节数字指示，第一个始终为8（在`level.dat`中除外，表示存储版本），第二个表示NBT结构的字节大小。例如：
    - `08 00 00 00` - `bf 00 00 00`
    - <始终为8> <始终为NBT结构的大小 - 不包括头部8字节>

## 小端
小端是将数字以字节形式写入流或文件的常用方法。这不是科学，容易理解。因此，如果Int16（短整型）值为`0x5a72`，则我们将其转换为字节[`0x5a`, `0x72`]，然后反转它们的顺序，即[`0x72`, `0x5a`]，并写入文件：`72 5a`。这可能看起来不合逻辑，但小端几乎总是在写入和读取文件时使用。单个`字节`在两种方法中都是相同的，因为它的大小为一个字节。例如：
- Int64（长整型）`0x11223344aabbccdd`
- 拆分为8个字节`0x11 0x22 0x33 0x44 0xAA 0xBB 0xCC 0xDD`
- 反转`0xDD 0xCC 0xBB 0xAA 0x44 0x33 0x22 0x11`
- 写入`dd cc bb aa   44 33 22 11`
- 完成（读取数字时只需反向进行此示例）。

## 网络小端
网络小端是一种不太常见的方法，仅在基岩协议中用于序列化NBT。它使用可变长度整数（也称为VarInts），而不是固定大小的整数。

VarInt以七位为块编码整数；每个字节的MSB在最后一个字节中清除。带符号值首先使用ZigZag编码转换为无符号表示（在下面链接的页面中也有描述），然后作为其他无符号数字进行编码。有关VarInts的更多信息，请参见[Google的proto buf文档](https://protobuf.dev/programming-guides/encoding/)。

NBT中的所有以下数据类型都由VarInts表示：`Int32`和`Int64`。（这不包括`字节`和`Int16`，以及使用小端编码的`浮点`和`双精度`，因此称为网络小端）。

进一步的更改：

- 字符串前缀由一个使用VarInt编码的Int32表示其长度。
- 列表也前缀由一个使用VarInt编码的Int32表示其长度。