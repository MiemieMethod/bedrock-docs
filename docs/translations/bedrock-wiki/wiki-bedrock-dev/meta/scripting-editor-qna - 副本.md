---
title: 脚本与编辑器问答 2023/09/22
category: 问答
mentions:
    - McMelonTV
    - SmokeyStack
---

此次问答在[基岩附加包 Discord](https://discord.gg/uZF75ZxcJq)中进行。十名微软/Mojang的员工加入我们，回答了有关脚本和编辑器API的问题。这些问题来自社区。

:::warning
并非所有消息都被复制过来，有些内容经过了编辑。如果您想查看全部内容，请加入上面的Discord，并获取“事件归档”角色。
:::

## 实体生命值API

- **问**：是否有计划通过脚本API增加对实体生命值更多的自定义，如更改最大生命值、取消伤害事件等？
- **答**：这是我们考虑中的内容，我们已经进行了讨论。

## 动态属性

- **问**：未来是否可以期待动态属性的一些改进，增加更复杂的类型，例如：
    - 物品：由于我们无法访问与这些类型相关的所有数据，因此无法将物品序列化为字符串。
    - 类型数组：有机会将字节数组直接保存到动态属性中，因为我们可以拥有比字符串更大的数组。
    - 什么是类型数组？这些：[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)
- **答**：好主意！

## NBT

- **问**：是否应该有一个特殊函数让我们可以获取与实体、物品或区块相关的原始数据。我不是说写入NBT（如果可以，那也很酷）。
    或者可以创建一个NBT API，允许读取和修改（而不是创建或插入）NBT标签。
- **答**：是的，我认为仅有原始访问——即使是只读的——也会让不同版本之间的兼容性问题过多（例如，如果某个属性改变了其功能）。而且里面有很多令人困惑的内容。

    我们可能更倾向于通过方法和API来封装NBT的内容，以更直接的方式进行处理。例如，对于ItemStack，其中一些成员是NBT的相对薄弱的封装。

## 您是如何设计API的？

- **问**：在API结构设计方面，您需要做出哪些决策，例如API有时使用方法而不是属性来检索信息，您为什么做出这些决定？
- **答**：关于方法与属性的具体决策，我们有一个内部的思考过程来决定。我会说我们并不是100%一致（这是一个不断演变的流程），但我们正在努力实现更多的一致性。
- **问**：构建新的/重新设计现有脚本功能的设计流程是什么？
- **答**：创建API的第一步是思考其使用场景。创作者希望通过此API实现哪些游戏玩法？这个系统的哪些部分需要公开？创作者希望能够修改这个系统的哪些部分，以及为什么？这有助于脑力风暴API的形状。如果API处于测试阶段，我们会尝试重新考虑这些问题，以防在创建测试API期间遗漏了任何重要的场景。

    在此阶段，我们还会考虑如何在代码库中实现它。有时我们会遇到某些限制，导致我们不得不以不同于预期的方式设计API。而有时我们会发现系统中更有趣的属性/功能，最终将其添加到API中。

    在考虑上述领域（场景和实现）时，我们尝试根据创作者的需求和我们能够在引擎中实现的能力来塑造API。然后我们制定一个规范文档，概述所有上述内容，以及API应如何呈现的提议。然后我们作为一个团队进行审查并共同迭代。一旦没有进一步的担忧和问题，我们便开始实现。

    当然，实现过程中有时会有新的发现，引发进一步的问题和担忧，导致我们进一步调整设计。

    关于方法与属性的要点是“是否简单（计算/设置不复杂）？如果是，使用属性，否则使用方法”。

- **问**：在设计API时，您追求哪些特性？
- **答**：其实有很多，但我认为可以归结为几个主要点：

    1. 我们能否正确保证该API的向后兼容性？它是否具有确定性的行为和时序？
    2. 它是否足够覆盖所需的场景，并与其他现有API良好交互？
    3. 它是否易于使用、类型明确（方便智能提示指导）且清晰？我们有大量的测试，并且在内部编写API的演示来确保它们易于使用。而且我非常支持让TypeScript类型帮助您更快地编写代码。
    4. 脚本API如何与现有的命令、JSON或Molang功能交互或比较？

    脚本的一个非常重要的目标是成为一个非常稳定的平台，用于构建体验，但我们也知道脚本是游戏更广泛的可扩展性表面的一部分。因此，可用性+可靠性和兼容性的结合非常重要。

- **问**：在实现新API时，您最不喜欢的部分是什么？将其集成到现有代码库中是否困难/复杂？
- **答**：作为一个非开发人员，我喜欢整个帮助设计API的过程。从决定哪些API对社区最重要，是创建还是从测试中移除，到进行设计讨论以决定如何使API完美，再到将其发布给您这些可爱的用户并获取反馈。也许这个过程最困难的部分是在实现开始时，我们在代码库中发现限制了我们计划的API设计的缺陷，需要调整设计计划。但我认为挑战是乐趣的一部分！🤪
- **问**：您如何决定为已有附加包中存在的系统设计接口？
- **答**：我们尽力在命名方面保持现有JSON组件与脚本之间的一致性，主要是为了便于创作者熟悉。然而，有时我们会觉得API在命名和/或接口上偏离会有益，因此这不是一个硬性规则。

    至于何时将API设为getter还是只读属性，我们尽力通过遵循一系列规则来保持一致。例如，执行复杂计算的API通常是getter，而简单返回常量或预计算值的API是属性。也就是说，这有点艺术性，在开发早期我们不是特别一致，所以有一些例外。

## 本地化

- **问**：目前我们只能通过typeId表示区块、物品、实体、效果和附魔，但我认为这不够用户友好。
    我建议添加属性或方法以获取在`texts`文件夹中定义的语言键。通过使用这些，我们可以将其放入RawMessage中，并根据用户的语言显示正确的名称。

    示例：

    ```js
    Block.rawName; // tile.dirt.name
    ItemStack.rawName; // item.bow.name
    Entity.rawName; // entity.cow.name
    Enchantment.rawName; // enchantment.durability
    ```
    
- **答**：好的反馈！我们确实希望在尽可能多的地方支持本地化文本字符串，如果我们不公开物品/区块等的本地化键，使用它们会很困难 😛

## 附加包中JSON的未来

- **问**：您是否计划未来减少使用JSON来创建附加包？
- **答**：我不会说我们一定想让“JSON使用减少”，但对于需要进行游戏逻辑的情况，我认为JSON的表达能力有一个上限，而提供像脚本这样更开放的方式更有优势。因此，对于某些事件，我们最终希望将它们连接到脚本作为主要的逻辑处理方式。不过，在逻辑领域我们可能仍会有一些“快捷方式”以保持简单场景的简便（例如，当某个事件触发时启动一个粒子效果等）。

## "minecraft:equippable"

- **问**：我知道你们刚刚更新了一个错误消息，当在副手栏放入奇怪的物品（如区块和主手物品）时会提示错误。然而，此更新限制了像我的“Any Offhand”模组。虽然错误消息有用，但如果能有办法绕过该错误并将任何物品装备到任何栏位将会很有帮助。我建议添加一个“forceEquip”选项。同时，我建议整体上为副手增加更多功能。
- **答**：反馈已记录。这最终归结为在赋予创作者无限灵活性的同时，施加约束以减少意外的游戏副作用、图形错误等。对于您的具体情况，您可能可以通过将副手组件添加到所有物品来绕过，尽管我明白这可能有点麻烦。

## @minecraft/vanilla-data 模块

- **问**：是否有计划内建此模块？手动包含它既不便捷，又让初学者感到困惑。
- **答**：不，我们没有计划将vanilla-data模块移入服务器模块。事实上，我们最初想将其从服务器模块中移除有一个重要原因：将API合约与数据合约解耦。具体来说，我们将所有脚本API模块视为一个强大的API合约，保证在选择特定版本时向后兼容。这个合约定义了可供使用的行为和功能，而不是游戏在任何给定时间点的内容类型。

    一个很好的例子是，您可以在基础游戏版本1.19.40或1.20.40上使用@minecraft/server 1.5.0，而“vanilla-data”（即可用的区块或物品类型）在这两个版本之间会有所不同。我们的API合约对这部分合约没有任何保证，仅对功能有保证。因此，当我们将数据放在服务器模块中时，我们会因为不必要的原因而频繁调整API，并在不同基础游戏版本上使用该模块时引发问题。

    但是！我们确实认为了解在任何给定基础游戏版本中可用的vanilla数据非常有价值，并且它确实使使用枚举调用API变得更容易，因此将其分离并按游戏版本进行版本控制是非常合理的。

    不过，这确实引入了一些工具问题，因为现在需要将JS作为行为包的一部分包含进去才能真正工作。总体来说，基线工具故事是我们经常考虑的内容（并且确实希望听到关于这方面的反馈！），我们也希望让代码打包变得非常简单，以适应您的工作流程。

    此外，目前我已经设置了vanilla数据，以便它被预打包在一个文件中，所以如果您不想进行任何TypeScript或打包工具，只需从包中获取JS并将其放入脚本文件夹中即可工作。

    但是TypeScript很棒 😄

## 区块功能

- **问**：我只是想要在脚本中有类似于Minecraft命令“/tickingarea”的功能。这样我们可以避免因区块未加载而导致的错误。也许还可以有一个卸载区块的功能。
- **答**：我认为我们想要在一个脚本编写者不需要考虑区块的世界中生存，但我不认为那是可能的，哈哈。所以我预计我们可能会推出一些基本的区块加载/卸载API。我想脚本版本的tickingarea命令可能会是第一步。所有关于承诺的免责声明，并且我认为我们短期内不会有任何，但可能中期会有。

## 最喜欢的创作

- **问**：您最喜欢的用脚本API创建的内容是什么？
- **答**：对我来说，其中一个比较奇怪的是一个ChatGPT集成演示（https://github.com/microsoft/minecraftcodex），这是在ChatGPT出现之前大约一年前完成的。我并不是AI专家；这是我第一次接触类似ChatGPT的东西，所以是我被AI的东西惊呆了（也许有点被吓到）。
- **答**：我对我所见到的物品堆叠传说数据库既感到印象深刻又感到害怕 😂

## 领域（Realms）

- **问**：为什么player.isOp()在领域中不起作用？
- **答**：这是我们需要进一步思考的事情。我们最初的`isOP`实现（测试版）相当简单，而权限API可能需要更强大，以匹配游戏在内部的实际工作方式。

## 运行时组件编辑

- **问**：是否有计划引入能够使用脚本API编辑实体、物品堆叠或区块上的组件，像旧的脚本API那样？
- **答**：我们经常讨论这个问题。很多组件还没有达到我们想要的程度，能够随意添加、移除或更新（例如，它们可能无法正确更新客户端，导致漏洞；或者因为其他组件没有以预期的方式设置，它们可能无法按预期工作）。其次，我们在讨论实体的“内部”应该有多深。例如，如果我创建了一个MikeMob，是否有一些与我的行为包完全无关的代码可以以一种可能混淆我代码的方式“修改MikeMob的内部”？组件组的组件状态是否被视为mob的“内部”设计？我认为我们还没有解决这个问题，但我们至少在朝着更多开放和减少“受保护内部”方向发展。抱歉啰嗦。

    但在短期或中期内，实体的“触发事件”以下的功能都不会有。同时，BeforeDataDrivenEntityTriggerEvent这个之前有一些有趣的设施用于修改组件组的事件可能也不会很快稳定下来，抱歉 😦

## 外部数据存储

- **问**：我们是否能通过例如JSON文件或MongoDB/mongoose之类的方式存储外部数据？
- **答**：目前，我们尽量在附加包（.mcaddons，来自Marketplace的内容）等内容周围保持一定的隔离，因此近期内不会有这种能力——也就是说，游戏内部的这些来源的脚本不会有这样的功能。
    （除非我们能想到一种巧妙的方法来保持隔离。）也许像浏览器一样，可以有某种形式的隔离索引存储，但随着动态属性（特别是现在限制更少）我预计其他人可能会做一个好的封装。

    专用服务器在这方面更像是一个游乐场——这是我们拥有更多服务器/网络相关内容的地方。我可以想象我们会在这里添加磁盘访问或其他通道功能……但我认为这不是首要任务，因此短期或中期内可能看不到相关功能；（尤其是因为服务器/网络已经有一种连接外部的方式）

## 表单

- **问**：未来是否可能在表单中加载网站？像NPC一样。
- **答**：如果是超链接，我们肯定需要对此保持谨慎，这是可以想象的，但这是一个很好的功能请求，已记录！

## 回放

- **问**：我是一个小型内容创作者，发现制作像Java内容创作者那样好的且酷的剪辑场景很困难。其他基岩内容创作者也有同样的问题。那么……是否有可能有某种回放功能，像Java的回放模组（或其代码）这样，或者我们也许可以自己制作一个？
- **答**：我非常喜欢回放模组，我知道这对基岩视频创作者会有巨大的帮助。我知道我们的摄像工作已经部分实现了这个目标，但我们仍需要做很多平台工作，以允许在基岩上开发回放模组。

## 速度（Velocity）

- **问**：是否有计划：
    1. 允许对玩家使用`applyImpulse`？只要`applyKnockback`正常工作，我看不出禁用它的理由。
    2. 允许为玩家使用`clearVelocity`？
    3. 允许在传送玩家时使用`keepVelocity`选项？
- **答**：由于技术限制，我们无法同时为玩家和其他实体提供这些API，但这是我们未来希望实现的功能。
- **答**：我们正在努力避免在测试版中添加没有短期发布计划的新API。我们不喜欢让API在测试版中存在一年以上。

## 命令一致性

- **问**：脚本的未来是否旨在使runCommand和runCommandAsync函数过时？
- **答**：在某些情况下，我们尝试优先考虑涵盖核心功能或超越命令功能的API——这在某种程度上留下了一个“中间地带”，仍然有一些关键任务需要使用命令来完成。随着时间的推移，我希望我们有一个可以完成命令所能做的一切的API。我不认为我们会弃用runCommand，但当然这是一个较低优先级的目标，以达到您不需要它们的地步。
- **答**：我们的目标之一是确保当您在脚本中时，非常不需要跳出脚本去执行命令，因为那样的跨范式工作会增加认知负担。您的例子就是一个很好的示例，说明API在提供一些“贴心功能”方面可能有价值，这些功能是基于我们今天拥有的更细粒度API之上的。感谢您提到这个场景！

## Minecraft调试器

- **问**：是否有计划解决仓库中的未解决问题？
- **答**：感谢指出这一点。我们将对调试器进行多次改进和错误修复，并且我们可能应该更积极地处理报告的问题，抱歉！我们最近刚刚进行了一些改进和错误修复，并且正在推进中，因此如果您在使用过程中遇到配置方面的问题，请继续报告问题，特别是如果您的工作流程与当前可用的配置有任何冲突。

## 错误日志

- **问**：更详细的错误日志？有时候我们不知道错误在哪里。
- **答**：这是很好的反馈。我们一直在努力改进此类错误消息。如果您有具体的代码示例，在哪些调用栈未包含时，请告诉我们。

    这些错误可能会非常令人沮丧！

## 脚本模板

- **问**：我们会有示例脚本模板吗？
- **答**：当然会的，我们知道这方面有很多空白。这是一个重点。我们确实有[脚本示例仓库](https://github.com/microsoft/minecraft-scripting-samples)（特别是[教程画廊](https://github.com/microsoft/minecraft-scripting-samples/tree/main/howto-gallery)是开源项目，如果您想提交编辑和示例，它们最终也会进入我们的文档）。我们确实有一些想法如何让它们更易于访问：)，敬请期待。

    更大的空白在于JSON方面——开始使用模板化的JSON文件是一个痛点，我们希望使其更容易，短期内没有计划，但我们肯定希望专注于此。

## 编辑器

## 更好的区块API？

- **问**：我们能期待编辑模式下有更复杂的区块API吗？或者也适用于基础API？
- **答**：我喜欢使用脚本中的BlockPaletteDefinition和ShapeTransformer的想法——我可以说，出于各种原因（性能、内存等），编辑器专用的多区块API正在考虑中。

## 开发构建（DEV Build）

- **问**：编辑器最终会与开发构建（DEV Build）相当，甚至更好吗，以帮助创作者制作内容？
- **答**：像所有游戏一样，我们有内部构建版本，具有调试工具。其中一些工具绝对会对创作者有帮助。我们希望将这些功能带给创作者，但今天还不能详细说明。

## 移动设备

- **问**：是否有将编辑器移植到移动设备的计划？
- **答**：我们目前专注于PC，首先使其成为最佳体验。

## 新功能

- **问**：计划添加哪些视觉元素？社区建议的哪些新功能和更简单的工具正在考虑中？
- **答**：我要在回答时保留一个警告，即以下我所陈述的内容可能会随着我们进行原型设计、开发和反馈而变化！

    说完这些……以下是我们正在考虑的一些可视化支持：

    1. **更多的小工具！** 我们有移动小工具和调整大小小工具，但我们希望添加旋转小工具，并且让小工具出现在粘贴预览区域。
    2. **带有实际预览的粘贴预览：** 现在它是一个空的区域，这不是特别有信息量！我们希望在该区域内添加您要粘贴内容的实际视觉效果。
    3. **画刷预览和结构放置：** 想象一下，画刷尖端不仅是一个单一的立方体，而是您即将绘制内容的形状和大小！并且想象一个世界，当您去放置一个结构时，您可以点击并拖动该结构到世界中并精确放置。

    让我们知道**您的**想法，并提供您认为对我们计划中有帮助的更多视觉反馈！

## 构建过程

- **问**：我在您的编辑器JavaScript文件中看到许多关于Webpack的引用。为什么选择Webpack而不是例如Rollup或ESBuild？您喜欢当前用于部署这些工具吗？
- **答**：很好的发现！事实上，如果您看看最近的[@minecraft/vanilla-data](https://github.com/microsoft/minecraft-scripting-addons)包，我们正在使用esbuild作为替代方案。实际上，这取决于工具的重量级程度以及它是否具备我们需要的自定义功能。

    编辑器是我们探索不同打包方式的地方，因此它首先使用了打包工具，但我们希望不断尝试替代方案，以改善我们的内部构建时间并最小化配置。