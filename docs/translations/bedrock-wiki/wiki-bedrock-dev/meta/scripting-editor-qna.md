---
title: 脚本与编辑器问答 2023/09/22
category: 问答
mentions:
    - McMelonTV
    - SmokeyStack
---

此次问答在[基岩附加包Discord](https://discord.gg/uZF75ZxcJq)中举行。十名微软/Mojang员工加入我们，回答了关于脚本和编辑器API的问题。问题来自社区。

:::warning
并非所有消息都被复制过来，有些内容经过了复制编辑。如果你想查看全部内容，请加入上述Discord，并获取“事件存档”角色。
:::

## 脚本

## 更好的摄像机

- **Q**：将来是否会通过脚本API实现摄像机的点旋转？
- **A**：摄像机路径的可视化（以及一般的路径）是一个很好的想法，也是我们一直在考虑的内容。

## 额外语言的更新情况？

- **Q**：在我们上一次的问答中讨论了额外语言的话题，回应是你们无法承诺添加对其他语言的官方支持。有没有任何变化，还是我们还要再等一年只能使用JS？
- **A**：这方面没有任何变化。我们的脚本系统与Javascript相当抽象，但支持多种语言运行时仍然需要巨大的开发成本。

## 通过ScriptAPI的世界生成

- **Q**：我已经抱怨这件事有一段时间了。在学习和模组《Legends》的过程中，我发现村庄和生物群系是通过他们的B#脚本系统放置的。Minecraft的ScriptAPI是否也有支持这一点的计划？
- **A**：对于游戏中的功能，我们会尝试找出最佳的API接口，以允许在其上进行自定义和修改。脚本功能非常强大，可能是世界生成的合适选择，但数据驱动的JSON定义等也可能适用于自定义。我会说，世界生成是我们听到很多的一个场景，我们将考虑各种API接口，以确定未来如何正确地公开这些功能。
- **Q**：获取生物群系的值，如生物群系气候、生物群系ID、噪声类型，还有方法getTags，获取生物群系的所有标签。
- **A**：收到了反馈——“生物群系发现”API将是未来一个不错的投资领域。

## QuickJS

- **Q**：是否有计划添加JIT编译以使脚本运行更流畅？
- **A**：挑战在于，即使是支持JIT的JS引擎（如V8），也并不支持我们所有的目标设备。
- **A**：在其他地方和这个线程中提到过，我们的JavaScript引擎不支持JIT。如果有一天我们转向不同的JS引擎，我们可以考虑在某些平台上实现JIT（不过不幸的是，我们的许多平台不支持JIT）。
- **Q**：是否有计划近期内放弃QuickJS？
- **A**：我们目前没有计划在近期内放弃QuickJS。
- **A**：我们确实旨在使脚本涵盖尽可能多的场景，确立正确的性能基线是其中的重要部分，也是我们希望继续改进的内容。这包括确保我们创建的API范式对常见用例具有高性能，以及对基本的QJS集成（和基岩引擎本身）的改进。

我们与Java模组框架，如Fabric，形成了鲜明对比，毕竟归根结底我们是在引擎之上提供一个版本契约，而不是直接修改引擎的方式。但我们希望它既易用又强大！

## 使用JS读取和（或）写入JSON

- **Q**：你们有计划允许使用JavaScript读取和写入JSON吗？
- **A**：是的，如果你将JSON文件放在你的脚本文件夹中，可以作为导入来读取，但是否有关于从脚本文件夹外读取JSON的问题？很不可能支持写入JSON。
- **A**：如果你希望为自己的用途拥有一个数据文件，并希望使用.json作为其创作格式，你应该可以通过将其放入你的脚本目录来实现。但这是只读数据。你不能在任何地方保存任意文件（.json或其他）。你不能直接从行为包的其他地方加载/解析.json文件。
- **A**：我可能会与几个人聊聊这个，因为我可能刚在引擎中进行原型设计，稍后会回复你😅。但我完全理解脚本内部的目标场景，也听到了关于脚本文件夹外的反馈，但这更为复杂。

## 脚本替代不仅仅是JSON事件

- **Q**：脚本是否会替代不仅仅是JSON事件？如果是这样，我们是否能够通过脚本制作行为，还是只能替代JSON事件？我可以看到需要通过脚本制作高级实体组件，甚至项目和方块组件，或许还能控制当其他脚本事件被触发或返回true时它们的行为。
- **A**：是的，脚本不仅仅是JSON事件，但脚本的范式仍然是事件驱动的（只是不局限于JSON事件）。这是一个很大的概括，但我认为大致上是JSON中的定义分离和脚本中的逻辑部分。因此，脚本将继续变得更强大，并希望与我们的更多系统集成。
- **A**：哈哈，我并没有说要接管，只是认为明确脚本与JSON的职责分工，并让它们良好互动是很重要的。你们应该能轻松知道在JSON中该做什么，什么时候跳转到脚本工作（反之亦然）🙂

## 脚本API存储系统

- **Q**：为什么动态属性现在不需要通过worldInitialize事件注册？
- **A**：我们基本上得出结论，任何限制都可以被绕过（例如通过在方块或告示牌上放置数据），用户可能会突然在长期地图中遇到限制，而且我们使API过于严格，以至于创建者仍在使用记分板作为数据库，这是我们希望避免的。

## 自定义ScriptAPI模块

- **Q**：我们是否能获得创建自定义ScriptAPI模块的能力？比如@minecraft/server-editor模块。
- **A**：捆绑！

## OreUI

- **Q**：我们是否能够在OreUI中使用外部React库？
- **A**：不幸的是，我们的引擎内置网页渲染器（支撑OreUI）为了性能进行了优化，并且并非100%符合标准。因此，第三方React库在这里通常不会像在完整的网页浏览器中那样呈现。

## 社区帮助

- **Q**：我们作为一个社区，如何帮助更多人了解脚本API？
- **A**：与编辑器相关的脚本... 😉 我们非常希望看到你们使用编辑器的视频，你们正在创建什么，以及实时看到你们的愿望和痛点！（以视频形式）这对团队非常有帮助！
- **A**：帮助我们确定社区学习这些内容所需的工具和文档！我们知道这很难，我们知道这很复杂。
- **A**：彼此友善。如果有人在挣扎，他们是脆弱的。所以如果你在使用脚本而他们没有，尽量不要表现得优越。尽你所能提供帮助和鼓励。
- **A**：关于视频内容——我知道这会帮助很多人。稳定的API在这里应该是安全的，因为我们需要在这些上提供向后兼容。

## 实体AI

- **Q**：我们是否会看到类似模拟玩家（minecraft/server-gametest）那样深入的实体行为控制？
- **A**：这不是我们目前正在开发的内容，但是的，我绝对希望我们能尽快推出好的AI API。标准免责声明——我们不会在近期内推出AI API。
- **Q**：我们应该能够强制AI目标启动、停止、改变优先级。
- **A**：已记录——希望在未来的版本中看到AI API（但短期内不会），我想最快的方法可能是通过某种形式直接或间接操作AI目标组件。

随意猜测，我觉得我们可以提供一部分AI原语（加上可能不需要AI目标的实体），而不必为每个AI目标都引入一个API——可能像模拟玩家API+++？——然后你们可以在此基础上构建更高层次的库；但如果这有用，与“只给我一种创建/读取/更新/删除所有AI目标的方法”相比，我们很想听听大家的看法。

## 数据保存

- **Q**：是否有为每个独特物品存储数据的计划？
- **A**：这是一个很好的反馈，绝对是我们正在考虑的内容。我们目前正在研究世界和实体动态属性，并计划很快开始考虑ItemStack动态属性！
- **A**：我们希望让创建者不再通过Lore存储元数据。😄
  我们最近移除了实体动态属性的注册，因此物品动态属性可能也会以同样的方式工作。
- **A**：我们正在研究！我们绝对不想让Lore成为ItemStack的数据存储解决方案，特别是因为Lore会与客户端同步。
- **Q**：从ItemStack类访问物品ID？
- **A**：与实体不同，物品堆可以被复制、合并和拆分，因此很难分配一个可靠的ID。作为替代方案，我们可能会考虑在运行时添加物品标签，或者简单地等到物品具有动态属性。
  
  我们很想听听关于物品ID有用的具体场景。
  
- **Q**：在离开世界时保存数据的新数据结构。
- **A**：如上所述，实体和世界动态属性是我们当前的存储解决方案。我们最近取消了动态属性的大小限制，并正在努力将API稳定发布给所有创建者。
  
  文件API是我们一直在讨论的内容。我们的主要目标之一是让玩家不再使用记分板进行存储，所以如果有我们可以做的，请告诉我们。
  
  我会记录下领域的UUID问题。
  
- **A**：根据上面的原始问题，我们也有点犹豫是否添加worldUnloadingSaveAllYourStuff事件，因为我们无法在所有平台上控制所有卸载动态（更不用说像崩溃等情况了）。所以我们的推荐策略是使用动态属性来持续状态。这当然有其自身的缺点（使代码对其进行健壮化可能很痛苦）。简而言之，我不确定我们是否有一个喜欢的策略来保存大量的游戏状态；我们将不得不根据你的反馈来调整这个策略。我们可能仍会有一些世界卸载事件，在那里我可以看到一些“持久化”的操作。

## 工作线程

- **Q**：我们是否会看到工作线程被实现，或有其他脚本语言选项，可以使用多线程？
- **A**：我们曾考虑过工作线程，目前没有立即的计划，但今天听到的用例很有价值。

## 为脚本引擎赋予更多能力

- **Q**：是否有计划允许某种形式的低级服务器世界数据访问？这样就不需要调用setblock/fill，可以通过函数调用获取整个区块，修改后再放回世界。
- **A**：我们希望提供更高性能的方块API。我同意setBlock在多方块操作中过于昂贵，而fill在尝试设置不同方块类型时过于限制。我们也讨论过拥有工作线程以执行大量计算而不让主服务器线程负担过重的可能性。
- **Q**：是否有计划允许用户更改命令队列中的命令数量？因为128对于某些任务来说可能有些限制。
- **A**：命令队列的限制是我们可以考虑的内容。对你来说，拥有一个查询命令队列大小的API是否有帮助？我很想听听你在受限时受到影响的场景。
- **Q**：是否有可能在世界启动时运行JS，而不是在RP和BP加载之前？这将允许动态生成纹理和物品，并使像Tinkers Construct这样的操作快很多。
- **A**：我们还没有研究这个，但这是我们会考虑的内容。

## 末影箱组件

- **Q**：Script API中是否会有末影箱组件？
- **A**：我认为我们没有将其列入待办事项，但这是很好的反馈！

## 斜杠命令

- **Q**：我们何时可以期待自定义斜杠命令注册？
- **A**：可能不会在近期内，但这是我们讨论过的内容。
- **A**：使用/scriptevent 😛

## 新事件

- **Q**：是否会有更多类似before事件的事件，比如entityHurt、entityDie等之前的事件？
- **A**：我们有这个想法，内部也在讨论🙂
- **Q**：是否计划添加物品传输事件？例如，物品移动、物品丢弃、物品拾取、物品给予、物品移除、物品修改、物品合并等。
- **A**：感谢提醒。这绝对是我们未来希望考虑添加的内容。
- **Q**：是否有计划添加BeforeCommandExecute事件？
- **A**：我不认为这是我们尚未考虑的事件。你想到的场景是什么？

## 客户端脚本

- **Q**：是否有可能允许使用客户端脚本进行客户端模组开发？或者让领域/世界上的脚本能够使用客户端端？如果这有意义的话？
- **A**：客户端脚本是经常被提及的，我们也认识到其价值。创建一个在客户端运行的JS实例并不难，但设计/创建/支持一个全新的客户端API是一项巨大的工作。这对API设计来说很困难（因为我们需要在许多形态因素上处理UI控件和输入方案），也是编写脚本的负担，因为它带来了两个不同脚本上下文的复杂性，并需要明确地在它们之间同步。
- **Q**：显然有许多客户端脚本模块正在开发中，但它们的路线图到底是什么？它们的意图和功能范围是什么？请告诉我们所有相关信息！
- **A**：大多数情况下，我们一直专注于服务器端脚本API，老实说，我们希望在服务器端添加API（例如/server-ui作为一个例子），以尽量保持对大多数开发者的简化。
  
  在某个时点，我们知道会有需要客户端脚本的场景——客户端验证、UI、输入管理等等——所以我们可能会跨过那座桥梁，拥有更正式的客户端脚本支持，但可能不会在短期或中期内实现。那里有一些棘手的问题。同样，我们的偏见是尽可能多地将功能放入服务器API中，以保持简洁。

- **A**：我知道我一个很大的想法也是尽量减少混淆。在考虑客户端脚本的场景中，它需要提供独特的价值，而不仅仅是服务器端的一个平行，因为它们在根本上是不同的。我们希望绝大多数场景可以由服务器处理（甚至编辑器也有自己的服务器端输入管理！），但我们也意识到对客户端脚本的兴趣，并且有些领域可能最好由它来服务。

## 更好的脚本 -> 数据驱动交互

- **Q**：我们能否获得更多在资源包和行为包上的脚本与数据驱动文件之间传递信息的方式？比如，能够在脚本中添加类似莫朗查询某个实体/附加对象的功能。例如，如果你想在脚本中设置实体骨骼的角度，你可以这样做：

```js
entity.setMolangFunction("wiki", "getMyAngle", () => {
    return 32;
});
```

然后在动画中，你可以写 `rotation: [0, "script.wiki:getMyAngle()", 0]`。这将允许诸如逆向运动学和从行为包运行动画，而不浪费q.skin_id或q.variant或编辑player.json。

- **A**：实体属性是解决方法！如果有任何实体属性不能满足你的需求的场景，请告诉我们。
  
  从客户端到服务器的回调这个想法很有趣，然而我们希望避免引入更多客户端权威的行为。

## 向量类的新增功能

- **Q**：我们能否增加一些向量的函数？
- **A**：这是一个很好的建议，也是我一直在思考的内容。ConMaster说得对，我们不想推广一种需要在紧密循环中频繁跳转JS与引擎的模式，因为那会很昂贵，但我们正在考虑是否为大家提供一些基础的帮助函数。

## Beta API

- **Q**：是否有计划将Beta-API从Beta阶段移出，作为正常功能集成到游戏中？
- **A**：是的！我们正在积极将许多API从Beta移入“稳定”版本！请查看每个版本的变更日志，我们通常会在其中包含这些更改。
  
  1.20.30和1.20.40对于非Beta API来说将是一个相当大的更新！

## 方块数据

- **Q**：类似于Entity.prototype.setProperty和ItemStack.prototype.setLore，未来是否有可能在方块中缓存/保存动态数据？
- **A**：我可能会建议使用动态属性或实体属性（有时称为“演员属性”）来持续状态。
  
  我认为我们希望将动态属性的概念引入ItemStack和方块（尽管方块也许可以通过在世界级别存储带有坐标的属性来等效实现）。不过，ItemStack和方块在底层需要更多的基础设施，这使得这项工作在计划中时间更长。
  （而且方块有方块状态，可能是为方块存储简单数据的一个好方法。）

## 市场

- **Q**：你们是否计划在市场中支持脚本？
- **A**：Spellrune是第一个支持脚本的市场地图，2022年夏天上线。自今年初以来，脚本已可用于所有市场地图。今天市场中有许多地图使用脚本。
  
  如果你还没有玩过Spellrune，它很棒，而且是免费的：https://www.minecraft.net/en-us/marketplace/pdp?id=f5cc05fc-616a-4963-a02b-5db3fcc9e311

## Websockets

- **Q**：ScriptAPI是否有计划添加WebSockets？
- **A**：我个人很喜欢在某些场景下使用WebSockets，但我认为我们官方不会很快在这方面做太多，甚至可能完全不做。这是一个不受支持的接口😦
  
  我肯定会想再审查一次WebSockets，以确保有一个脚本等价的所有数据（例如，WebSockets的事件等），然后你可以通过dedicated server上的server-net输送数据。

## 实体生命值API

- **Q**：是否有计划通过脚本API增加对实体生命值更多的自定义，如更改最大生命值、取消伤害事件等？
- **A**：这是我们考虑中的内容，我们已经进行了讨论。

## 动态属性

- **Q**: 未来是否可以期待动态属性的改进，包含更复杂的类型，例如：
    - 物品：我们无法正确地将物品序列化为字符串，因为我们无法访问与这些类型相关的所有数据。
    - 类型化数组：有机会将字节数组直接保存到动态属性，因为我们可以使用比字符串更大的数组。
    - 什么是类型化数组？这些：[TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)。
- **A**: 很棒的想法！

## NBT

- **Q**: 应该有一个特殊的函数可以用来获取与实体、物品或方块相关的原始数据。我不是指编写 NBT（如果可以，这会很酷）。
    或者可以创建一个 NBT API，允许读取和修改（而不是创建或插入）NBT 标签。
- **A**: 是的，我认为仅有原始访问——即使是只读的，也会让人们容易受到版本间的兼容性问题影响（例如，如果某个属性改变了其功能）。而且其中有很多令人困惑的内容。

我们可能更倾向于通过方法和 API 来封装 NBT，以便更直接地提供帮助。例如，对于 `itemstack`，其中一些成员相对来说是 NBT 的薄封装。

## 你们是如何设计 API 的？

- **Q**: 关于 API 结构，你们做出了哪些决策，比如有时 API 使用方法而不是属性来检索信息，为什么做出这些决策？
- **A**: 具体到方法和属性，我们有一个内部的思考过程来决定。我会说我们并不百分之百一致（这是一个不断发展的过程），但我们正在努力实现更多的一致性。
- **Q**: 在构建新的或重新设计现有的脚本功能时，你们的设计流程是怎样的？
- **A**: 创建 API 的第一步是思考它将被使用的场景。创作者希望通过这个 API 实现什么样的游戏玩法？系统的哪些部分需要公开？创作者希望能够修改系统的哪些部分，为什么？这有助于我们为 API 勾勒出形状。如果一个 API 处于测试阶段，我们会重新考虑这些问题，以防在创建测试 API 时遗漏了任何重要的场景。

在这个阶段，我们还会考虑如何在代码库中实现它。有时我们会遇到某些限制，导致我们不得不以不同于预期的方式设计 API。有时我们会发现系统中更有趣的属性/功能，最终将其添加到 API 中。

在考虑上述领域（场景和实现）的同时，我们尝试根据创作者的需求和我们在引擎中能够实现的内容来塑造 API。然后，我们制定了一份规范文档，概述了所有上述内容，以及 API 应该如何构建的提案。然后我们作为一个团队进行审查并共同迭代。一旦没有进一步的担忧和问题，我们就开始实施。

当然，在实施过程中发现的问题有时会引发更多的问题和担忧，导致我们进一步调整设计。

关于方法和属性的关键在于“它是否简单（不复杂计算/设置）？如果是，作为属性，否则作为方法。”

- **Q**: 你们在制作 API 时追求哪些特质？
- **A**: 有很多方面，但我认为可以归结为几个主要点：

    1. 我们是否能够正确保证这个 API 的向后兼容性？它是否有确定性的行为和时序？
    2. 它是否能充分覆盖所需的场景，并且与其他现有 API 良好交互？
    3. 它是否易于使用，类型是否明确（便于智能提示），且清晰明了？我们有大量的测试，并且内部编写 API 演示以确保其易用性。我也是 TypeScript 类型帮助你更快编写代码的坚定支持者。
    4. 脚本 API 如何与命令、JSON 或 molang 的现有功能交互或比较？

    脚本的一个重要目标是成为一个超级稳定的平台来构建体验，但我们也知道脚本是游戏更广泛可扩展性表面的一部分。因此，可用性、可靠性和兼容性的结合非常重要。

- **Q**: 实现新 API 最不喜欢的部分是什么？将其整合到现有代码库中是否困难/复杂？
- **A**: 作为一个非开发者，我喜欢整个设计 API 的过程。从决定哪些 API 对社区最重要，从创建或撤出测试阶段，到进行设计讨论以决定如何让 API 达到最佳，再到发布给你们这些可爱的用户并获取反馈。也许这个过程中最困难的部分是当实施开始时，我们发现代码库中的一些限制因素阻碍了我们原本的 API 设计计划，导致我们不得不调整设计计划。但我认为挑战也是乐趣的一部分！🤪
- **Q**: 你们如何决定为附加包中已存在的系统设计接口？
- **A**: 我们尽力在命名上保持现有 JSON 组件与脚本之间的一致，主要是为了创作者的熟悉感。然而，有时我们会觉得 API 在命名和/或界面上有所偏离能够带来好处，所以这不是一个硬性规则。

    至于何时将 API 设计为 getter 还是只读属性，我们尽力通过遵循一系列规则来保持一致。例如，执行复杂计算的 API 通常是 getter，简单返回常量或预计算值的 API 则是属性。也就是说，这有点艺术性，在开发初期我们并不超级一致，所以有一些例外情况。

## 本地化

- **Q**: 目前我们只能通过 typeId 表示方块、物品、实体、效果和附魔，但我觉得这对用户体验不友好。
    我建议添加属性或方法来获取 `texts` 文件夹中定义的语言键。通过使用这些，我们可以将其放入 RawMessage 并根据用户的语言显示适当的名称。

    例如：

  ```js
    Block.rawName; // tile.dirt.name
    ItemStack.rawName; // item.bow.name
    Entity.rawName; // entity.cow.name
    Enchantment.rawName; // enchantment.durability
  ```
    
- **A**: 好的反馈！我们绝对希望在尽可能多的地方支持本地化的文本字符串，如果我们不公开物品/方块等的本地化键，使用它们会很困难 😛

## 附加包中 JSON 的未来

- **Q**: 你们是否计划让 JSON 在创建附加包中的使用减少？
- **A**: 我不会说我们一定要让“JSON 使用减少”，但对于希望进行游戏逻辑的情况，我认为 JSON 的表达能力有一个上限，而脚本则提供了更开放的选项。因此，对于某些事件，我们最终希望将它们连接到脚本作为主要的逻辑处理方式。不过，在逻辑领域，我们仍可能在保持简单场景的情况下使用一些“快捷方式”（例如事件触发时启动粒子效果等）。

## "minecraft:equippable"

- **Q**: 我知道你们刚刚更新了一个错误信息，当在副手槽中放入奇怪的物品（如方块和主手物品）时会提示错误。然而，这次更新限制了像我的“AnyThing副手”这样的模组。虽然错误信息很有用，但如果能够有办法 _绕过_ 错误并将任何物品装备到任何槽位，将会很有帮助。我建议添加一个“forceEquip”选项。同时，我建议增加副手的更多功能。
- **A**: 已记录反馈。最终，这取决于在赋予创作者无限灵活性的同时，设置约束以减少意外的游戏玩法副作用、图形错误等。

    对于你的具体场景，你可能可以通过为所有物品添加副手组件来绕过，尽管我理解这可能有点麻烦。

## @minecraft/vanilla-data 模块

- **Q**: 你们是否计划内置这个模块？手动包含它既不方便，也让初学者感到困惑。
- **A**: 不，我们没有计划将 vanilla-data 模块移入 server。事实上，我们最初想将其从 server 中移出的一个重要原因是：将 API 合约与数据合约解耦。具体来说，我们认为所有的脚本 API 模块都是一个强有力的 API 合约，当选择特定版本时，我们保证其向后兼容性。这个合约实际上定义了你们可以使用的行为和功能，而不是当前游戏中任何时间点的内容类型。

    一个好的例子是，你可以在基岩版基础游戏版本 1.19.40 或 1.20.40 上使用 @minecraft/server 1.5.0，而“vanilla-data”（即你可用的方块或物品类型）在这两个版本之间会有所不同。我们的 API 合约并不保证那部分合约，只有功能方面的保证。所以，当我们以前将那些数据放在 server 模块中时，我们会因为不必要的原因频繁调整 API，并且在不同基础游戏版本上使用该模块时会出现问题。

    但是！我们确实认为，了解在任何给定的基础游戏版本中你可用的 vanilla 数据非常有价值，并且这确实使得使用枚举调用 API 更加容易，因此将其分离出来并按游戏版本进行版本控制非常有意义。

    不过，这确实带来了一些工具问题，因为现在需要将 JS 作为行为包的一部分包含进来才能真正工作。一般来说，基础的工具链是我们经常思考的（并且肯定想听到相关反馈！），我们也希望使代码打包变得非常容易，以配合你的工作流程。

    此外，现在我已经设置好了 vanilla 数据，使其预打包在一个单一文件中，所以如果你不想进行任何 TypeScript 或打包工具，只需从包中获取 JS 并将其放入你的脚本文件夹中即可正常工作。

    但 TypeScript 很棒 😄

## 区块功能

- **Q**: 我只是想在脚本中有一些类似于 Minecraft 命令 “/tickingarea” 的功能。这样我们就可以避免因区块未加载而产生的错误。也许还可以有一个卸载区块的功能。
- **A**: 我认为我们曾希望让脚本编写者无需考虑区块，但我觉得那是不可能的 lol。所以我预计我们可能会引入一些基本的区块加载/卸载 API。我想脚本等同于 tickingarea 命令可能是第一步。关于承诺方面的问题，以及我们不会在短期内提供任何功能，但可能在中期内会有。

## 最喜欢的创作

- **Q**: 你们最喜欢用脚本 API 创建的内容是什么？
- **A**: 对我来说，最奇怪的一个是一个 ChatGPT 集成演示（[https://github.com/microsoft/minecraftcodex](https://github.com/microsoft/minecraftcodex)），大约在 ChatGPT 出现之前一年完成。我并不是 AI 专家；那是我第一次接触 ChatGPT 类似的东西，所以我被 AI 的东西所震撼（也许还有一点被吓到）。
- **A**: 我对我见过的物品堆栈传说数据库既感到震撼又感到害怕 😂

## 王者领域 (Realms)

- **Q**: 为什么 player.isOp() 在 Realm 中不起作用？
- **A**: 这是我们需要更多思考的事情。我们最初的 `isOP` 实现（测试版）相当天真，权限 API 可能需要更加健全，以匹配游戏在幕后实际运行的方式。

## 运行时组件编辑

- **Q**: 是否有计划通过脚本 API 来编辑实体、物品堆栈或方块的组件，就像旧的脚本 API 一样？
- **A**: 我们经常就这个问题进行讨论。许多组件还不够... 或许还未达到我们希望的程度... 随意添加、移除或更新（例如，它们可能不会正确更新客户端，导致漏洞；或者可能因为其他组件未正确设置而以意想不到的方式工作）。其次，我们在讨论一个实体的“内部”应该有多开放。例如，如果我创建了一个 MikeMob，完全不相关的代码是否能够以某种可能混淆我代码的方式“篡改” MikeMob 的内部？组件组的组件状态是否被视为一个实体的“内部”设计？我认为我们还没有解决这个问题，但至少我们正在朝着更多开放和较少“受保护的内部”方向前进。抱歉啰嗦。

    但在短期或中期内，实体的 `triggerEvent` 以下的内容都不会有变化。在 Stable 版本中，BeforeDataDrivenEntityTriggerEvent 也不会有太大变化，抱歉 😦

## 外部数据存储

- **Q**: 我们是否有可能使用例如 JSON 文件或 MongoDB/mongoose 等方式来存储外部数据？
- **A**: 目前，我们尝试在附加包（.mcaddons，来自市场的内容等）周围保持一定的隔离，因此短期内不太可能为来自这些来源的脚本提供这种能力——即在游戏内。
    （除非我们能想到一个巧妙的方法来保持其隔离。）也许像浏览器一样，可以有某种形式的隔离索引存储，但对于动态属性（尤其是现在限制较少），我预期其他人可能会做一个良好的封装。

    专用服务器在这方面更像一个游乐场——那里有更多的服务器/网络相关内容。我可以预见我们会在那里添加磁盘访问或其他通道……但这不是首要任务，所以可能不会在短期或中期内看到这些功能；（特别是因为服务器/网络已经有一种连接外部的方式）

## 表单

- **Q**: 未来是否有可能在表单中加载一个网站？比如 NPC。
- **A**: 如果是超链接，我们肯定需要对此保持谨慎，但这是一个很好的功能请求，已记录！

## 回放

- **Q**: 我是一个小型内容创作者，我发现制作像 Java 内容创作者那样好的酷炫剪辑有困难。其他基岩内容创作者也有同样的问题。那么...是否有可能有某种回放功能，像 Java 的回放模组（或者相关代码），让我们自己制作一个？
- **A**: 我是回放模组的忠实粉丝，我知道这对基岩视频创作者会有巨大的帮助。我知道我们的摄像工作在一定程度上实现了这一目标，但要让一个回放模组在基岩上开发出来，我们还需要做很多平台方面的工作。

## 速度 (Velocity)

- **Q**: 你们是否有计划：
    1. 允许对玩家使用 `applyImpulse`？只要 `applyKnockback` 工作正常，我看不出禁用它的原因。
    2. 允许对玩家使用 `clearVelocity`？
    3. 当传送玩家时允许使用 `keepVelocity` 选项？
- **A**: 由于技术限制，我们无法同时为玩家和其他实体提供这些 API，但这是我们未来希望能够实现的功能。
- **A**: 我们正试图避免在测试版中添加没有短期发布计划的新 API。我们不喜欢让 API 在测试版中存在一年以上。

## 命令一致性

- **Q**: 脚本的未来是否打算让 `runCommand` 和 `runCommandAsync` 函数过时？
- **A**: 在某些情况下，我们优先考虑了覆盖核心功能或超越命令功能的 API——这在某种程度上留下了一个“中间”空白，仍然有一些关键任务需要通过命令来完成。随着时间的推移，我希望我们能为命令中你能做的一切都有相应的 API。我不指望我们会弃用 `runCommand`，但确实希望其成为一个不再需要的低优先级目标。
- **A**: 我们的目标之一是确保当你在脚本中时，很少需要跳出脚本去执行命令，因为那种跨范式的工作增加了认知负担。但你的例子是一个很好的例子，说明一些在我们目前更细粒度的 API 之上提供一些“贴心功能”的 API 可能是有价值的。感谢你指出这个场景！

## Minecraft 调试器

- **Q**: 你们是否有计划解决仓库中的开放问题？
- **A**: 感谢你指出这一点。我们将会继续改进和修复调试器中的错误，并且我们可能应该更主动地解决已报告的问题，抱歉！我们最近已经做了一些改进和错误修复，并且其正在进行中，所以请继续在遇到问题时报告，特别是如果你的工作流程与当前可用的配置有任何冲突时。

## 错误日志

- **Q**: 更多详细的错误日志？有时我们不知道错误在哪里。
- **A**: 这是很好的反馈。我们一直在努力改进这样的错误信息。如果你有具体的代码示例，说明调用堆栈没有包含，请告诉我们。

    这些错误可能会非常令人沮丧！

## 脚本模板

- **Q**: 我们会有示例脚本模板吗？
- **A**: 当然会，我们知道这方面有很多不足。这是一个重点。我们确实有 [minecraft-scripting-samples](https://github.com/microsoft/minecraft-scripting-samples)（尤其是 How To Gallery [这里](https://github.com/microsoft/minecraft-scripting-samples/tree/main/howto-gallery)），这些都是开源项目，如果你想提交编辑和样本，可以这样做（这些最终也会进入我们的文档）。我们确实有一些想法，如何让它们更易于访问 :），敬请期待。

    我认为更大的缺口在于 JSON 部分 —— 使用模板化的 JSON 文件入门非常麻烦，我们希望能够简化这一过程，短期内没有计划，但我们肯定想将其作为重点。

## 编辑器

## 更好的方块 API？

- **Q**: 我们是否可以期待编辑器模式中更复杂的方块 API？或者也适用于基础 API？
- **A**: 我喜欢从脚本中使用 `BlockPaletteDefinition` 和 `ShapeTransformer` 的想法 —— 我可以说，基于编辑器的多方块 API 在考虑中，原因有很多（性能、内存等）。

## 开发构建 (DEV Build)

- **Q**: 编辑器最终能否在帮助创作者制作内容方面与 DEV 构建（或更好）持平？
- **A**: 和所有游戏一样，我们有内部构建版本，包含调试工具。其中一些工具绝对会对创作者有帮助。我们希望将这些功能带给创作者，但今天没有具体的可谈内容。

## 移动端

- **Q**: 有计划将编辑器移植到移动设备吗？
- **A**: 我们正专注于 PC，以先打造最佳体验。

## 新功能

- **Q**: 你们计划添加哪些视觉元素？社区建议的新功能和更易用的工具有哪些？
- **A**: 我会带着以下免责声明来回答，下面所述的内容在我们进行原型设计、开发和获取反馈时可能会有所改变！

    说完这些……以下是我们正在考虑的几个可视化支持功能：

    1. **更多的小工具！** 我们有移动小工具和缩放小工具，但我们希望添加旋转小工具，并且在粘贴预览体积时也出现小工具。
    2. **带有实际预览的粘贴预览：** 现在它是一个空的体积，这并不太直观！我们希望在该体积内添加你正在粘贴内容的实际视觉效果。
    3. **画笔预览和结构放置：** 想象一下，画笔尖不仅仅是一个方块，而是你将要绘制内容的形状和大小！想象一下，当你去放置一个结构时，你可以点击拖拽该结构到世界中并精确放置。

    让我们知道**你的**想法，并提供更多你认为对我们有帮助的视觉内容，以便我们将其添加到我们的计划中！

## 构建流程

- **Q**: 我注意到你的编辑器 JavaScript 文件中有很多关于 Webpack 的引用。为什么选择 Webpack 而不是，比如 Rollup 或 ESBuild？你们喜欢当前用于部署的工具链吗？
- **A**: 好的观察！事实上，如果你查看我们最近的 @minecraft/vanilla-data 包，我们在那里使用了 esbuild 作为替代方案。实际上，这取决于工具的重量级程度以及它是否具有我们需要的自定义功能。

    编辑器是我们探索不同库打包方式的地方，所以它最先使用了打包工具，但我们希望继续尝试替代方案，以提高内部构建时间并最小化配置。